// Seriously awesome GLSL noise functions. (C) Credits and kudos go to
// Copyright (C) Stefan Gustavson, Ian McEwan Ashima Arts
// MIT License. 
// Google keywords: GLSL simplex noise


define permute1(x){
	return mod((34.0 * x + 1.0) * x, 289.0)
}

define permute3(vec3 x){
	return mod((34.0 * x + 1.0) * x, 289.0)
}

define permute4(vec4 x){
	return mod((34.0 * x + 1.0) * x, 289.0)
}

define isqrtT1(float r){
	return 1.79284291400159 - 0.85373472095314 * r
}

define isqrtT4(vec4 r){
	return vec4(1.79284291400159 - 0.85373472095314 * r)
}

define snoise2(float x, float y){
	return snoise2(vec2(x,y,z))
}

define snoise2(vec2 v){
	vec4 C = vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439)
	vec2 i  = floor(v + dot(v, C.yy) )
	vec2 x0 = v -   i + dot(i, C.xx)

	vec2 i1
	i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0)
	vec4 x12 = x0.xyxy + C.xxzz
	x12.xy -= i1

	i = mod(i, 289.0) // Avoid truncation effects in permutation
	vec3 p = permute3(permute3(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0 ))

	vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0)
	m = m*m
	m = m*m

	vec3 x = 2.0 * fract(p * C.www) - 1.0
	vec3 h = abs(x) - 0.5
	vec3 ox = floor(x + 0.5)
	vec3 a0 = x - ox

	m *= (1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h ))
	vec3 g
	g.x  = a0.x  * x0.x  + h.x  * x0.y
	g.yz = a0.yz * x12.xz + h.yz * x12.yw
	return 130.0 * dot(m, g)
}

define snoise3(float x, float y, float z){
	return snoise3(vec3(x,y,z))
}

define snoise3(vec3 v){
	vec2 C = vec2(1.0/6.0, 1.0/3.0)
	vec4 D = vec4(0.0, 0.5, 1.0, 2.0)

	// First corner
	vec3 i = floor(v + dot(v, C.yyy))
	vec3 x0 = v - i + dot(i, C.xxx)
	vec3 g = step(x0.yzx, x0.xyz)
	vec3 l = 1.0 - g
	vec3 i1 = min(g.xyz, l.zxy)
	vec3 i2 = max(g.xyz, l.zxy)
	vec3 x1 = x0 - i1 + 1.0 * C.xxx
	vec3 x2 = x0 - i2 + 2.0 * C.xxx
	vec3 x3 = x0 - 1. + 3.0 * C.xxx

	// Permutations
	i = mod(i, 289.0)
	vec4 p = permute4(permute4(permute4( 
		i.z + vec4(0.0, i1.z, i2.z, 1.0))
		+ i.y + vec4(0.0, i1.y, i2.y, 1.0)) 
		+ i.x + vec4(0.0, i1.x, i2.x, 1.0))

	// ( N*N points uniformly over a square, mapped onto an octahedron.)
	float n_ = 1.0/7.0
	vec3 ns = n_ * D.wyz - D.xzx
	vec4 j = p - 49.0 * floor(p * ns.z *ns.z)
 	vec4 x_ = floor(j * ns.z)
	vec4 y_ = floor(j - 7.0 * x_)
	vec4 x = x_ * ns.x + ns.yyyy
	vec4 y = y_ * ns.x + ns.yyyy
	vec4 h = 1.0 - abs(x) - abs(y)
	vec4 b0 = vec4( x.xy, y.xy )
	vec4 b1 = vec4( x.zw, y.zw )
	vec4 s0 = floor(b0)*2.0 + 1.0
	vec4 s1 = floor(b1)*2.0 + 1.0
	vec4 sh = -step(h, vec4(0.0))
	vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy
	vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww
	vec3 p0 = vec3(a0.xy, h.x)
	vec3 p1 = vec3(a0.zw, h.y)
	vec3 p2 = vec3(a1.xy, h.z)
	vec3 p3 = vec3(a1.zw, h.w)

	//Normalise gradients
	vec4 norm = isqrtT4(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)))
	p0 *= norm.x;
	p1 *= norm.y;
	p2 *= norm.z;
	p3 *= norm.w;

	// Mix final noise value
	vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0)
	m = m * m
	return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
		dot(p2,x2), dot(p3,x3) ) )
}

define snoise4_g(float j, vec4 ip){
	vec4 p
	p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0
	p.w = 1.5 - dot(abs(p.xyz), vec3(1.0,1.0,1.0))
	vec4 s = vec4(lessThan(p, vec4(0.0)))
	p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www
	return p
}

define snoise4(float x, float y, float z, float w){
	return snoise4(vec4(x,y,z,w))
}

define snoise4(vec4 v){

	vec4 C = vec4(0.138196601125011,0.276393202250021,0.414589803375032,-0.447213595499958)
	// First corner
	vec4 i  = floor(v + dot(v, vec4(0.309016994374947451)) )
	vec4 x0 = v - i + dot(i, C.xxxx)
	vec4 i0
	vec3 isX = step( x0.yzw, x0.xxx )
	vec3 isYZ = step( x0.zww, x0.yyz )
	i0.x = isX.x + isX.y + isX.z
	i0.yzw = 1.0 - isX
	i0.y += isYZ.x + isYZ.y
	i0.zw += 1.0 - isYZ.xy
	i0.z += isYZ.z
	i0.w += 1.0 - isYZ.z
	vec4 i3 = clamp( i0, 0.0, 1.0 )
	vec4 i2 = clamp( i0-1.0, 0.0, 1.0 )
	vec4 i1 = clamp( i0-2.0, 0.0, 1.0 )
	vec4 x1 = x0 - i1 + C.xxxx
	vec4 x2 = x0 - i2 + C.yyyy
	vec4 x3 = x0 - i3 + C.zzzz
	vec4 x4 = x0 + C.wwww
	// Permutations
	i = mod(i, 289.0 )
	float j0 = permute1( permute1( permute1( permute1(i.w) + i.z) + i.y) + i.x)
	vec4 j1 = permute4( permute4( permute4( permute4(
		i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))
		+ i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))
		+ i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))
		+ i.x + vec4(i1.x, i2.x, i3.x, 1.0 ))
	// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope
	// 7*7*6 = 294, which is close to the ring size 17*17 = 289.
	vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0)
	vec4 p0 = snoise4_g(j0,   ip)
	vec4 p1 = snoise4_g(j1.x, ip)
	vec4 p2 = snoise4_g(j1.y, ip)
	vec4 p3 = snoise4_g(j1.z, ip)
	vec4 p4 = snoise4_g(j1.w, ip)
	// Normalise gradients
	vec4 nr = isqrtT4(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)))
	p0 *= nr.x
	p1 *= nr.y
	p2 *= nr.z
	p3 *= nr.w
	p4 *= isqrtT1(dot(p4,p4))
	// Mix contributions from the five corners
	vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0)
	vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)), 0.0)
	m0 = m0 * m0
	m1 = m1 * m1

	return 49.0 * (dot(m0*m0, vec3(dot( p0, x0 ), dot(p1, x1), dot(p2, x2)))
		+ dot(m1*m1, vec2( dot(p3, x3), dot(p4, x4))))
}

define cell(vec2 v){
	return cell2(vec3(v.x, v.y,0))
}

define cell2(vec3 P){
	float K = 0.142857142857 // 1/7
	float Ko = 0.428571428571 // 1/2-K/2
	float K2 = 0.020408163265306 // 1/(7*7)
	float Kz = 0.166666666667 // 1/6
	float Kzo = 0.416666666667 // 1/2-1/6*2
	float ji = 0.8 // smaller jitter gives less errors in F2
	vec3 Pi = mod(floor(P), 289.0)
	vec3 Pf = fract(P)
	vec4 Pfx = Pf.x + vec4(0.0, -1.0, 0.0, -1.0)
	vec4 Pfy = Pf.y + vec4(0.0, 0.0, -1.0, -1.0)
	vec4 p = permute4(Pi.x + vec4(0.0, 1.0, 0.0, 1.0))
	p = permute4(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0))
	vec4 p1 = permute4(p + Pi.z) // z+0
	vec4 p2 = permute4(p + Pi.z + vec4(1.0)) // z+1
	vec4 ox1 = fract(p1*K) - Ko
	vec4 oy1 = mod(floor(p1*K), 7.0)*K - Ko
	vec4 oz1 = floor(p1*K2)*Kz - Kzo // p1 < 289 guaranteed
	vec4 ox2 = fract(p2*K) - Ko
	vec4 oy2 = mod(floor(p2*K), 7.0)*K - Ko
	vec4 oz2 = floor(p2*K2)*Kz - Kzo
	vec4 dx1 = Pfx + ji*ox1
	vec4 dy1 = Pfy + ji*oy1
	vec4 dz1 = Pf.z + ji*oz1
	vec4 dx2 = Pfx + ji*ox2
	vec4 dy2 = Pfy + ji*oy2
	vec4 dz2 = Pf.z - 1.0 + ji*oz2
	vec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1 // z+0
	vec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2 // z+1

	vec4_d= min(d1,d2) // F1 is now in d
	d2 = max(d1,d2) // Make sure we keep all candidates for F2
	d.xy = (d.x < d.y) ? d.xy : d.yx // Swap smallest to d.x
	d.xz = (d.x < d.z) ? d.xz : d.zx
	d.xw = (d.x < d.w) ? d.xw : d.wx // F1 is now in d.x
	d.yzw = min(d.yzw, d2.yzw) // F2 now not in d2.yzw
	d.y = min(d.y, d.z) // nor in d.z
	d.y = min(d.y, d.w) // nor in d.w
	d.y = min(d.y, d2.x) // F2 is now in d.y
	return sqrt(d.xy) // F1 and F2
}

define cell3(vec3 P){
	float K = 0.142857142857
	float Ko = 0.428571428571 // 1/2-K/2
	float K2 = 0.020408163265306// 1/(7*7)
	float Kz = 0.166666666667// 1/6
	float Kzo = 0.416666666667// 1/2-1/6*2
	float ji = 1.0// smaller jitter gives more regular pattern

	vec3 Pi = mod(floor(P), 289.0)
	vec3 Pf = fract(P) - 0.5

	vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0)
	vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0)
	vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0)

	vec3 p = permute3(Pi.x + vec3(-1.0, 0.0, 1.0))
	vec3 p1 = permute3(p + Pi.y - 1.0)
	vec3 p2 = permute3(p + Pi.y)
	vec3 p3 = permute3(p + Pi.y + 1.0)
	vec3 p11 = permute3(p1 + Pi.z - 1.0)
	vec3 p12 = permute3(p1 + Pi.z)
	vec3 p13 = permute3(p1 + Pi.z + 1.0)
	vec3 p21 = permute3(p2 + Pi.z - 1.0)
	vec3 p22 = permute3(p2 + Pi.z)
	vec3 p23 = permute3(p2 + Pi.z + 1.0)
	vec3 p31 = permute3(p3 + Pi.z - 1.0)
	vec3 p32 = permute3(p3 + Pi.z)
	vec3 p33 = permute3(p3 + Pi.z + 1.0)

	vec3 ox11 = fract(p11*K) - Ko
	vec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko
	vec3 oz11 = floor(p11*K2)*Kz - Kzo // p11 < 289 guaranteed
	vec3 ox12 = fract(p12*K) - Ko
	vec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko
	vec3 oz12 = floor(p12*K2)*Kz - Kzo
	vec3 ox13 = fract(p13*K) - Ko
	vec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko
	vec3 oz13 = floor(p13*K2)*Kz - Kzo
	vec3 ox21 = fract(p21*K) - Ko
	vec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko
	vec3 oz21 = floor(p21*K2)*Kz - Kzo
	vec3 ox22 = fract(p22*K) - Ko
	vec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko
	vec3 oz22 = floor(p22*K2)*Kz - Kzo
	vec3 ox23 = fract(p23*K) - Ko
	vec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko
	vec3 oz23 = floor(p23*K2)*Kz - Kzo
	vec3 ox31 = fract(p31*K) - Ko
	vec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko
	vec3 oz31 = floor(p31*K2)*Kz - Kzo
	vec3 ox32 = fract(p32*K) - Ko
	vec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko
	vec3 oz32 = floor(p32*K2)*Kz - Kzo
	vec3 ox33 = fract(p33*K) - Ko
	vec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko
	vec3 oz33 = floor(p33*K2)*Kz - Kzo

	vec3 dx11 = Pfx + ji*ox11
	vec3 dy11 = Pfy.x + ji*oy11
	vec3 dz11 = Pfz.x + ji*oz11
	vec3 dx12 = Pfx + ji*ox12
	vec3 dy12 = Pfy.x + ji*oy12
	vec3 dz12 = Pfz.y + ji*oz12
	vec3 dx13 = Pfx + ji*ox13
	vec3 dy13 = Pfy.x + ji*oy13
	vec3 dz13 = Pfz.z + ji*oz13
	vec3 dx21 = Pfx + ji*ox21
	vec3 dy21 = Pfy.y + ji*oy21
	vec3 dz21 = Pfz.x + ji*oz21
	vec3 dx22 = Pfx + ji*ox22
	vec3 dy22 = Pfy.y + ji*oy22
	vec3 dz22 = Pfz.y + ji*oz22
	vec3 dx23 = Pfx + ji*ox23
	vec3 dy23 = Pfy.y + ji*oy23
	vec3 dz23 = Pfz.z + ji*oz23
	vec3 dx31 = Pfx + ji*ox31
	vec3 dy31 = Pfy.z + ji*oy31
	vec3 dz31 = Pfz.x + ji*oz31
	vec3 dx32 = Pfx + ji*ox32
	vec3 dy32 = Pfy.z + ji*oy32
	vec3 dz32 = Pfz.y + ji*oz32
	vec3 dx33 = Pfx + ji*ox33
	vec3 dy33 = Pfy.z + ji*oy33
	vec3 dz33 = Pfz.z + ji*oz33

	vec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11
	vec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12
	vec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13
	vec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21
	vec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22
	vec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23
	vec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31
	vec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32
	vec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33

	vec3 d1a = min(d11, d12)
	d12 = max(d11, d12)
	d11 = min(d1a, d13) // Smallest now not in d12 or d13
	d13 = max(d1a, d13)
	d12 = min(d12, d13) // 2nd smallest now not in d13
	vec3 d2a = min(d21, d22)
	d22 = max(d21, d22)
	d21 = min(d2a, d23) // Smallest now not in d22 or d23
	d23 = max(d2a, d23)
	d22 = min(d22, d23) // 2nd smallest now not in d23
	vec3 d3a = min(d31, d32)
	d32 = max(d31, d32)
	d31 = min(d3a, d33) // Smallest now not in d32 or d33
	d33 = max(d3a, d33)
	d32 = min(d32, d33) // 2nd smallest now not in d33
	vec3 da = min(d11, d21)
	d21 = max(d11, d21)
	d11 = min(da, d31) // Smallest now in d11
	d31 = max(da, d31) // 2nd smallest now not in d31
	d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx
	d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx // d11.x now smallest
	d12 = min(d12, d21) // 2nd smallest now not in d21
	d12 = min(d12, d22) // nor in d22
	d12 = min(d12, d31) // nor in d31
	d12 = min(d12, d32) // nor in d32
	d11.yz = min(d11.yz,d12.xy) // nor in d12.yz
	d11.y = min(d11.y,d12.z) // Only two more to go
	d11.y = min(d11.y,d11.z) // Done! (Phew!)
	return sqrt(d11.xy) // F1, F2
}